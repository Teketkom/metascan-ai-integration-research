#!/usr/bin/env python3
"""
AI-Powered Nmap NSE Script Generator
Автоматическая генерация Lua NSE скриптов на основе LLM

Author: Dmitriy Shalimov
Project: Metascan AI Integration Research
"""

import argparse
import json
import os
import re
from typing import Dict, List, Optional
from dataclasses import dataclass
import openai
from jinja2 import Template


@dataclass
class VulnerabilityInfo:
    """Информация о уязвимости"""
    cve_id: str
    description: str
    severity: str
    affected_services: List[str]
    exploitation_method: str
    detection_pattern: str
    cvss_score: float


class NSEScriptGenerator:
    """Генератор NSE скриптов на основе AI"""
    
    # Шаблон Lua скрипта
    LUA_TEMPLATE = """
-- Nmap NSE Script: {{ script_name }}
-- Generated by AI NSE Generator
-- CVE: {{ cve_id }}
-- Severity: {{ severity }} (CVSS: {{ cvss_score }})
-- Generated: {{ timestamp }}

local shortport = require "shortport"
local http = require "http"
local stdnse = require "stdnse"
local string = require "string"
local vulns = require "vulns"

description = [[
{{ description }}

Affected Services:
{% for service in affected_services %}
- {{ service }}
{% endfor %}

Exploitation Method:
{{ exploitation_method }}

References:
- https://nvd.nist.gov/vuln/detail/{{ cve_id }}
- https://cve.mitre.org/cgi-bin/cvename.cgi?name={{ cve_id }}
]]

---
-- @usage
-- nmap --script {{ script_name }} -p <port> <target>
--
-- @output
-- PORT   STATE SERVICE
-- 80/tcp open  http
-- | {{ script_name }}:
-- |   VULNERABLE:
-- |   {{ cve_id }}
-- |     State: VULNERABLE
-- |     Risk factor: {{ severity }}
-- |     Description:
-- |       {{ description | truncate(100) }}
-- |     Disclosure date: {{ disclosure_date }}
-- |     References:
-- |_      https://nvd.nist.gov/vuln/detail/{{ cve_id }}
---

author = "AI NSE Generator / Metascan Research"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"vuln", "safe", "intrusive"}

-- Правило выбора порта ({{ port_rule_description }})
portrule = {{ port_rule }}

-- Главная функция скрипта
action = function(host, port)
    local vuln_table = {
        title = "{{ cve_id }}: {{ description | truncate(80) }}",
        state = vulns.STATE.NOT_VULN,
        risk_factor = "{{ severity }}",
        scores = {
            CVSSv3 = "{{ cvss_score }}",
        },
        description = [[
{{ description }}
        ]],
        references = {
            "https://nvd.nist.gov/vuln/detail/{{ cve_id }}",
            "https://cve.mitre.org/cgi-bin/cvename.cgi?name={{ cve_id }}"
        },
        dates = {
            disclosure = {year = '{{ disclosure_year }}', month = '{{ disclosure_month }}', day = '{{ disclosure_day }}'},
        },
    }

    local vuln_report = vulns.Report:new(SCRIPT_NAME, host, port)
    
    -- Проверка уязвимости
    {{ detection_code | indent(4) }}
    
    return vuln_report:make_output(vuln_table)
end
    """
    
    def __init__(self, api_key: Optional[str] = None):
        """Инициализация генератора"""
        self.api_key = api_key or os.getenv('OPENAI_API_KEY')
        if self.api_key:
            openai.api_key = self.api_key
    
    def fetch_cve_info(self, cve_id: str) -> VulnerabilityInfo:
        """
        Получение информации о CVE из базы данных или API
        В реальной реализации интегрировать с NVD API
        """
        # TODO: Интеграция с NVD API
        # https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}
        
        # Пример заглушки (заменить на реальный API запрос)
        return VulnerabilityInfo(
            cve_id=cve_id,
            description="Remote code execution vulnerability in web service",
            severity="CRITICAL",
            affected_services=["HTTP", "HTTPS"],
            exploitation_method="POST request to /admin/upload endpoint",
            detection_pattern="Specific response header pattern",
            cvss_score=9.8
        )
    
    def generate_detection_code(self, vuln_info: VulnerabilityInfo) -> str:
        """
        Генерация Lua кода для детектирования уязвимости с помощью LLM
        """
        if not self.api_key:
            # Fallback: базовый шаблон без LLM
            return self._generate_basic_detection(vuln_info)
        
        # Промпт для LLM
        prompt = f"""
Generate Lua code for Nmap NSE script to detect {vuln_info.cve_id}.

Vulnerability Details:
- CVE: {vuln_info.cve_id}
- Description: {vuln_info.description}
- Exploitation: {vuln_info.exploitation_method}
- Detection Pattern: {vuln_info.detection_pattern}

Requirements:
1. Use Nmap NSE libraries (http, stdnse, string)
2. Implement safe detection (no exploitation)
3. Return vuln_table.state = vulns.STATE.VULN if vulnerable
4. Include error handling
5. Add logging with stdnse.debug1()

Generate only the detection code block (Lua), not the full script.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert in Lua and Nmap NSE scripting. Generate secure, efficient detection code."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=1000
            )
            
            lua_code = response.choices[0].message.content
            # Очистка от markdown форматирования
            lua_code = re.sub(r'^```lua\n|^```\n|```$', '', lua_code, flags=re.MULTILINE)
            return lua_code.strip()
            
        except Exception as e:
            print(f"[!] LLM generation failed: {e}. Using fallback template.")
            return self._generate_basic_detection(vuln_info)
    
    def _generate_basic_detection(self, vuln_info: VulnerabilityInfo) -> str:
        """Базовый шаблон детектирования (без LLM)"""
        return f"""
stdnse.debug1("Testing for {vuln_info.cve_id}")

-- Попытка подключения к целевому сервису
local response = http.get(host, port, "/")

if not response or not response.status then
    stdnse.debug1("No response from target")
    return vuln_report:make_output(vuln_table)
end

-- Проверка паттерна уязвимости
if response.status == 200 and response.body then
    if string.match(response.body, "{vuln_info.detection_pattern}") or
       string.match(response.header["server"] or "", "vulnerable.*version") then
        vuln_table.state = vulns.STATE.VULN
        stdnse.debug1("VULNERABLE: {vuln_info.cve_id} detected!")
    else
        stdnse.debug1("Pattern not matched, likely not vulnerable")
    end
else
    stdnse.debug1("Unexpected response status: " .. tostring(response.status))
end
        """
    
    def generate_script(self, vuln_info: VulnerabilityInfo, output_path: str):
        """Генерация полного NSE скрипта"""
        
        # Генерация кода детектирования
        detection_code = self.generate_detection_code(vuln_info)
        
        # Подготовка данных для шаблона
        template_data = {
            'script_name': f"{vuln_info.cve_id.lower().replace('-', '_')}_detect",
            'cve_id': vuln_info.cve_id,
            'description': vuln_info.description,
            'severity': vuln_info.severity,
            'cvss_score': vuln_info.cvss_score,
            'affected_services': vuln_info.affected_services,
            'exploitation_method': vuln_info.exploitation_method,
            'detection_code': detection_code,
            'port_rule': self._generate_port_rule(vuln_info.affected_services),
            'port_rule_description': f"Matches {', '.join(vuln_info.affected_services)} services",
            'timestamp': '2024-11-26',
            'disclosure_year': '2024',
            'disclosure_month': '11',
            'disclosure_day': '01',
            'disclosure_date': '2024-11-01'
        }
        
        # Рендер шаблона
        template = Template(self.LUA_TEMPLATE)
        script_content = template.render(**template_data)
        
        # Сохранение в файл
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(script_content)
        
        print(f"[+] NSE script generated: {output_path}")
        print(f"[+] CVE: {vuln_info.cve_id}")
        print(f"[+] Severity: {vuln_info.severity} (CVSS: {vuln_info.cvss_score})")
        print(f"\n[*] Usage: nmap --script {os.path.basename(output_path)} -p <port> <target>")
    
    def _generate_port_rule(self, services: List[str]) -> str:
        """Генерация правила выбора порта"""
        if 'HTTP' in services or 'HTTPS' in services:
            return "shortport.http"
        elif 'SSH' in services:
            return "shortport.ssh"
        elif 'FTP' in services:
            return "function(host, port) return port.number == 21 end"
        else:
            return "shortport.port_or_service({80, 443, 8080}, {'http', 'https'})"


def main():
    parser = argparse.ArgumentParser(
        description='AI-Powered Nmap NSE Script Generator',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python ai_nse_generator.py --cve CVE-2024-1234 --output scripts/cve_2024_1234.nse
  python ai_nse_generator.py --cve CVE-2023-5678 --api-key YOUR_OPENAI_KEY
        """
    )
    
    parser.add_argument('--cve', required=True, help='CVE ID (e.g., CVE-2024-1234)')
    parser.add_argument('--output', default='generated_script.nse', help='Output file path')
    parser.add_argument('--api-key', help='OpenAI API key (or set OPENAI_API_KEY env var)')
    parser.add_argument('--no-ai', action='store_true', help='Disable AI generation, use templates only')
    
    args = parser.parse_args()
    
    # Инициализация генератора
    generator = NSEScriptGenerator(api_key=None if args.no_ai else args.api_key)
    
    # Получение информации о CVE
    print(f"[*] Fetching information for {args.cve}...")
    vuln_info = generator.fetch_cve_info(args.cve)
    
    # Генерация скрипта
    print(f"[*] Generating NSE script...")
    generator.generate_script(vuln_info, args.output)
    
    print("\n[+] Done!")


if __name__ == '__main__':
    main()
